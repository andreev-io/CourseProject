[
    {
        "success": true,
        "question": {
            "id": 69025133,
            "raw": "<p>For a given list of tuples, if multiple tuples in the list have the first element of tuple the same - among them select only the tuple with the maximum last element.</p>\n<p>For example:</p>\n<pre><code>sample_list = [(5,16,2),(5,10,3),(5,8,1),(21,24,1)]\n</code></pre>\n<p>In the <code>sample_list</code> above since the first 3 tuples has the similar first element <code>5</code> in this case among them only the 2nd tuple should be retained since it has the max last element =&gt; <code>3</code>.</p>\n<p>Expected op:</p>\n<pre><code>op = [(5,10,3),(21,24,1)]\n</code></pre>\n<p>Code:</p>\n<pre><code>op = []\nfor m in range(len(sample_list)):\n    li = [sample_list[m]]\n    for n in range(len(sample_list)):\n        if(sample_list[m][0] == sample_list[n][0]\n           and sample_list[m][2] != sample_list[n][2]):\n            li.append(sample_list[n])\n    op.append(sorted(li,key=lambda dd:dd[2],reverse=True)[0])\n\nprint (list(set(op)))\n</code></pre>\n<p>This works. But it is very slow for long list. Is there a more pythonic or efficient way to do this?</p>\n",
            "plain": "For a given list of tuples, if multiple tuples in the list have the first element of tuple the same - among them select only the tuple with the maximum last element.\nFor example:\nsample_list = [(5,16,2),(5,10,3),(5,8,1),(21,24,1)]\n\nIn the sample_list above since the first 3 tuples has the similar first element 5 in this case among them only the 2nd tuple should be retained since it has the max last element => 3.\nExpected op:\nop = [(5,10,3),(21,24,1)]\n\nCode:\nop = []\nfor m in range(len(sample_list)):\n    li = [sample_list[m]]\n    for n in range(len(sample_list)):\n        if(sample_list[m][0] == sample_list[n][0]\n           and sample_list[m][2] != sample_list[n][2]):\n            li.append(sample_list[n])\n    op.append(sorted(li,key=lambda dd:dd[2],reverse=True)[0])\n\nprint (list(set(op)))\n\nThis works. But it is very slow for long list. Is there a more pythonic or efficient way to do this?\n"
        },
        "answer": {
            "id": 69025180,
            "raw": "<p>You could use a <a href=\"https://docs.python.org/3/library/collections.html#collections.defaultdict\" rel=\"noreferrer\">defaultdict</a> to group tuples that have the same first element and then take the maximum of each group based on the third:</p>\n<pre><code>from collections import defaultdict\n\nsample_list = [(5,16,2),(5,10,3),(5,8,1),(21,24,1)]\n\nd = defaultdict(list)\nfor e in sample_list:\n    d[e[0]].append(e)\n\nres = [max(val, key=lambda x: x[2]) for val in d.values()]\nprint(res)\n</code></pre>\n<p><strong>Output</strong></p>\n<pre><code>[(5, 10, 3), (21, 24, 1)]\n</code></pre>\n<p>This approach is <code>O(n)</code>.</p>\n",
            "plain": "You could use a defaultdict to group tuples that have the same first element and then take the maximum of each group based on the third:\nfrom collections import defaultdict\n\nsample_list = [(5,16,2),(5,10,3),(5,8,1),(21,24,1)]\n\nd = defaultdict(list)\nfor e in sample_list:\n    d[e[0]].append(e)\n\nres = [max(val, key=lambda x: x[2]) for val in d.values()]\nprint(res)\n\nOutput\n[(5, 10, 3), (21, 24, 1)]\n\nThis approach is O(n).\n",
            "reference_link": "https://docs.python.org/3/library/collections.html#collections.defaultdict",
            "link_context": "defaultdict"
        }
    },
    {
        "success": true,
        "question": {
            "id": 69276894,
            "raw": "<p>Assuming the following:</p>\n<pre><code>&gt;&gt;&gt; square = '\u00b2'      # Superscript Two (Unicode U+00B2)\n&gt;&gt;&gt; cube  = '\u00b3'       # Superscript Three (Unicode U+00B3)\n</code></pre>\n<p>Curiously:</p>\n<pre><code>&gt;&gt;&gt; square.isdigit()\nTrue\n&gt;&gt;&gt; cube.isdigit()\nTrue\n</code></pre>\n<p>OK, let's convert those &quot;digits&quot; to integer:</p>\n<pre><code>&gt;&gt;&gt; int(square)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nValueError: invalid literal for int() with base 10: '\u00b2'\n&gt;&gt;&gt; int(cube)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nValueError: invalid literal for int() with base 10: '\u00b3'\n</code></pre>\n<p>Oooops!</p>\n<p>Could someone please explain what behavior I should expect from the <code>str.isdigit()</code> method when handling strings?</p>\n",
            "plain": "Assuming the following:\n>>> square = '\u00b2'      # Superscript Two (Unicode U+00B2)\n>>> cube  = '\u00b3'       # Superscript Three (Unicode U+00B3)\n\nCuriously:\n>>> square.isdigit()\nTrue\n>>> cube.isdigit()\nTrue\n\nOK, let's convert those \"digits\" to integer:\n>>> int(square)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: '\u00b2'\n>>> int(cube)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: '\u00b3'\n\nOooops!\nCould someone please explain what behavior I should expect from the str.isdigit() method when handling strings?\n"
        },
        "answer": {
            "id": 69276922,
            "raw": "<p><a href=\"https://docs.python.org/3/library/stdtypes.html#str.isdigit\" rel=\"noreferrer\"><code>str.isdigit</code></a> doesn't claim to be related to parsability as an <code>int</code>. It's reporting a simple Unicode property, is it a decimal character or digit of some sort:</p>\n<blockquote>\n<p><strong><code>str.isdigit()</code></strong></p>\n<p>Return <code>True</code> if all characters in the string are digits and there is at least one character, <code>False</code> otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.</p>\n</blockquote>\n<p>In short, <code>str.isdigit</code> is thoroughly useless for detecting valid numbers. The correct solution to checking if a given string is a legal integer is to call <code>int</code> on it, and catch the <code>ValueError</code> if it's not a legal integer. Anything else you do will be (badly) reinventing the same tests the actual parsing code in <code>int()</code> performs, so why not let it do the work in the first place?</p>\n<p>Side-note: You're using the term &quot;utf-8&quot; incorrectly. UTF-8 is a specific way of encoding Unicode, and only applies to raw binary data. Python's <code>str</code> is an &quot;idealized&quot; Unicode text type; it has no encoding (under the hood, it's stored encoded as one of ASCII, latin-1, UCS-2, UCS-4, and possibly also UTF-8, but none of that is visible at the Python layer outside of indirect measurements like <code>sys.getsizeof</code>, which only hints at the underlying encoding by letting you see how much memory the string consumes). The characters you're talking about are simple Unicode characters above the ASCII range, they're not specifically UTF-8.</p>\n",
            "plain": "str.isdigit doesn't claim to be related to parsability as an int. It's reporting a simple Unicode property, is it a decimal character or digit of some sort:\n\nstr.isdigit()\nReturn True if all characters in the string are digits and there is at least one character, False otherwise. Digits include decimal characters and digits that need special handling, such as the compatibility superscript digits. This covers digits which cannot be used to form numbers in base 10, like the Kharosthi numbers. Formally, a digit is a character that has the property value Numeric_Type=Digit or Numeric_Type=Decimal.\n\nIn short, str.isdigit is thoroughly useless for detecting valid numbers. The correct solution to checking if a given string is a legal integer is to call int on it, and catch the ValueError if it's not a legal integer. Anything else you do will be (badly) reinventing the same tests the actual parsing code in int() performs, so why not let it do the work in the first place?\nSide-note: You're using the term \"utf-8\" incorrectly. UTF-8 is a specific way of encoding Unicode, and only applies to raw binary data. Python's str is an \"idealized\" Unicode text type; it has no encoding (under the hood, it's stored encoded as one of ASCII, latin-1, UCS-2, UCS-4, and possibly also UTF-8, but none of that is visible at the Python layer outside of indirect measurements like sys.getsizeof, which only hints at the underlying encoding by letting you see how much memory the string consumes). The characters you're talking about are simple Unicode characters above the ASCII range, they're not specifically UTF-8.\n",
            "reference_link": "https://docs.python.org/3/library/stdtypes.html#str.isdigit",
            "link_context": "str.isdigit"
        }
    }
]